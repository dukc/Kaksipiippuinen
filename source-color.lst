       |module arsd.color;
       |
       |@safe:
       |
       |// importing phobos explodes the size of this code 10x, so not doing it.
       |
       |private {
       |        real toInternal(T)(string s) {
0000000|                real accumulator = 0.0;
0000000|                size_t i = s.length;
0000000|                foreach(idx, c; s) {
0000000|                        if(c >= '0' && c <= '9') {
0000000|                                accumulator *= 10;
0000000|                                accumulator += c - '0';
0000000|                        } else if(c == '.') {
0000000|                                i = idx + 1;
0000000|                                break;
       |                        } else
0000000|                                throw new Exception("bad char to make real from " ~ s);
       |                }
       |
0000000|                real accumulator2 = 0.0;
0000000|                real count = 1;
0000000|                foreach(c; s[i .. $]) {
0000000|                        if(c >= '0' && c <= '9') {
0000000|                                accumulator2 *= 10;
0000000|                                accumulator2 += c - '0';
0000000|                                count *= 10;
       |                        } else
0000000|                                throw new Exception("bad char to make real from " ~ s);
       |                }
       |
0000000|                return accumulator + accumulator2 / count;
       |        }
       |
       |        @trusted
       |        string toInternal(T)(int a) {
0000000|                if(a == 0)
0000000|                        return "0";
0000000|                char[] ret;
0000000|                while(a) {
0000000|                        ret ~= (a % 10) + '0';
0000000|                        a /= 10;
       |                }
0000000|                for(int i = 0; i < ret.length / 2; i++) {
0000000|                        char c = ret[i];
0000000|                        ret[i] = ret[$ - i - 1];
0000000|                        ret[$ - i - 1] = c;
       |                }
0000000|                return cast(string) ret;
       |        }
       |        string toInternal(T)(real a) {
       |                // a simplifying assumption here is the fact that we only use this in one place: toInternal!string(cast(real) a / 255)
       |                // thus we know this will always be between 0.0 and 1.0, inclusive.
0000000|                if(a <= 0.0)
0000000|                        return "0.0";
0000000|                if(a >= 1.0)
0000000|                        return "1.0";
0000000|                string ret = "0.";
       |                // I wonder if I can handle round off error any better. Phobos does, but that isn't worth 100 KB of code.
0000000|                int amt = cast(int)(a * 1000);
0000000|                return ret ~ toInternal!string(amt);
       |        }
       |
0000000|        real absInternal(real a) { return a < 0 ? -a : a; }
       |        real minInternal(real a, real b, real c) {
0000000|                auto m = a;
0000000|                if(b < m) m = b;
0000000|                if(c < m) m = c;
0000000|                return m;
       |        }
       |        real maxInternal(real a, real b, real c) {
0000000|                auto m = a;
0000000|                if(b > m) m = b;
0000000|                if(c > m) m = c;
0000000|                return m;
       |        }
       |        bool startsWithInternal(string a, string b) {
0000000|                return (a.length >= b.length && a[0 .. b.length] == b);
       |        }
       |        string[] splitInternal(string a, char c) {
0000000|                string[] ret;
0000000|                size_t previous = 0;
0000000|                foreach(i, char ch; a) {
0000000|                        if(ch == c) {
0000000|                                ret ~= a[previous .. i];
0000000|                                previous = i + 1;
       |                        }
       |                }
0000000|                if(previous != a.length)
0000000|                        ret ~= a[previous .. $];
0000000|                return ret;
       |        }
       |        string stripInternal(string s) {
0000000|                foreach(i, char c; s)
0000000|                        if(c != ' ' && c != '\t' && c != '\n') {
0000000|                                s = s[i .. $];
0000000|                                break;
       |                        }
0000000|                for(int a = cast(int)(s.length - 1); a > 0; a--) {
0000000|                        char c = s[a];
0000000|                        if(c != ' ' && c != '\t' && c != '\n') {
0000000|                                s = s[0 .. a + 1];
0000000|                                break;
       |                        }
       |                }
       |
0000000|                return s;
       |        }
       |}
       |
       |// done with mini-phobos
       |
       |/// Represents an RGBA color
       |struct Color {
       |        union {
       |                ubyte[4] components;
       |
       |                struct {
       |                        ubyte r; /// red
       |                        ubyte g; /// green
       |                        ubyte b; /// blue
       |                        ubyte a; /// alpha. 255 == opaque
       |                }
       |
       |                uint asUint;
       |        }
       |
       |        // this makes sure they are in range before casting
       |        static Color fromIntegers(int red, int green, int blue, int alpha = 255) {
0000000|                if(red < 0) red = 0; if(red > 255) red = 255;
0000000|                if(green < 0) green = 0; if(green > 255) green = 255;
0000000|                if(blue < 0) blue = 0; if(blue > 255) blue = 255;
0000000|                if(alpha < 0) alpha = 0; if(alpha > 255) alpha = 255;
0000000|                return Color(red, green, blue, alpha);
       |        }
       |
       |        /// .
   2984|        this(int red, int green, int blue, int alpha = 255) {
       |                // workaround dmd bug 10937
   2984|                if(__ctfe)
0000000|                        this.components[0] = cast(ubyte) red;
       |                else
   2984|                        this.r = cast(ubyte) red;
   2984|                this.g = cast(ubyte) green;
   2984|                this.b = cast(ubyte) blue;
   2984|                this.a = cast(ubyte) alpha;
       |        }
       |
       |        /// Convenience functions for common color names
0000000|        static Color transparent() { return Color(0, 0, 0, 0); }
0000000|        static Color white() { return Color(255, 255, 255); } ///.
   1492|        static Color black() { return Color(0, 0, 0); } ///.
0000000|        static Color red() { return Color(255, 0, 0); } ///.
0000000|        static Color green() { return Color(0, 255, 0); } ///.
0000000|        static Color blue() { return Color(0, 0, 255); } ///.
0000000|        static Color yellow() { return Color(255, 255, 0); } ///.
0000000|        static Color teal() { return Color(0, 255, 255); } ///.
0000000|        static Color purple() { return Color(255, 0, 255); } ///.
       |
       |        /*
       |        ubyte[4] toRgbaArray() {
       |                return [r,g,b,a];
       |        }
       |        */
       |
       |        /// Makes a string that matches CSS syntax for websites
       |        string toCssString() {
0000000|                if(a == 255)
0000000|                        return "#" ~ toHexInternal(r) ~ toHexInternal(g) ~ toHexInternal(b);
       |                else {
0000000|                        return "rgba("~toInternal!string(r)~", "~toInternal!string(g)~", "~toInternal!string(b)~", "~toInternal!string(cast(real)a / 255.0)~")";
       |                }
       |        }
       |
       |        /// Makes a hex string RRGGBBAA (aa only present if it is not 255)
       |        string toString() {
0000000|                if(a == 255)
0000000|                        return toCssString()[1 .. $];
       |                else
0000000|                        return toRgbaHexString();
       |        }
       |
       |        /// returns RRGGBBAA, even if a== 255
       |        string toRgbaHexString() {
0000000|                return toHexInternal(r) ~ toHexInternal(g) ~ toHexInternal(b) ~ toHexInternal(a);
       |        }
       |
       |        /// Gets a color by name, iff the name is one of the static members listed above
       |        static Color fromNameString(string s) {
0000000|                Color c;
0000000|                foreach(member; __traits(allMembers, Color)) {
       |                        static if(__traits(compiles, c = __traits(getMember, Color, member))) {
0000000|                                if(s == member)
0000000|                                        return __traits(getMember, Color, member);
       |                        }
       |                }
0000000|                throw new Exception("Unknown color " ~ s);
       |        }
       |
       |        /// Reads a CSS style string to get the color. Understands #rrggbb, rgba(), hsl(), and rrggbbaa
       |        static Color fromString(string s) {
0000000|                s = s.stripInternal();
       |
0000000|                Color c;
0000000|                c.a = 255;
       |
       |                // trying named colors via the static no-arg methods here
0000000|                foreach(member; __traits(allMembers, Color)) {
       |                        static if(__traits(compiles, c = __traits(getMember, Color, member))) {
0000000|                                if(s == member)
0000000|                                        return __traits(getMember, Color, member);
       |                        }
       |                }
       |
       |                // try various notations borrowed from CSS (though a little extended)
       |
       |                // hsl(h,s,l,a) where h is degrees and s,l,a are 0 >= x <= 1.0
0000000|                if(s.startsWithInternal("hsl(") || s.startsWithInternal("hsla(")) {
0000000|                        assert(s[$-1] == ')');
0000000|                        s = s[s.startsWithInternal("hsl(") ? 4 : 5  .. $ - 1]; // the closing paren
       |
0000000|                        real[3] hsl;
0000000|                        ubyte a = 255;
       |
0000000|                        auto parts = s.splitInternal(',');
0000000|                        foreach(i, part; parts) {
0000000|                                if(i < 3)
0000000|                                        hsl[i] = toInternal!real(part.stripInternal);
       |                                else
0000000|                                        a = cast(ubyte) (toInternal!real(part.stripInternal) * 255);
       |                        }
       |
0000000|                        c = .fromHsl(hsl);
0000000|                        c.a = a;
       |
0000000|                        return c;
       |                }
       |
       |                // rgb(r,g,b,a) where r,g,b are 0-255 and a is 0-1.0
0000000|                if(s.startsWithInternal("rgb(") || s.startsWithInternal("rgba(")) {
0000000|                        assert(s[$-1] == ')');
0000000|                        s = s[s.startsWithInternal("rgb(") ? 4 : 5  .. $ - 1]; // the closing paren
       |
0000000|                        auto parts = s.splitInternal(',');
0000000|                        foreach(i, part; parts) {
       |                                // lol the loop-switch pattern
0000000|                                auto v = toInternal!real(part.stripInternal);
0000000|                                switch(i) {
0000000|                                        case 0: // red
0000000|                                                c.r = cast(ubyte) v;
0000000|                                        break;
0000000|                                        case 1:
0000000|                                                c.g = cast(ubyte) v;
0000000|                                        break;
0000000|                                        case 2:
0000000|                                                c.b = cast(ubyte) v;
0000000|                                        break;
0000000|                                        case 3:
0000000|                                                c.a = cast(ubyte) (v * 255);
0000000|                                        break;
0000000|                                        default: // ignore
       |                                }
       |                        }
       |
0000000|                        return c;
       |                }
       |
       |
       |
       |
       |                // otherwise let's try it as a hex string, really loosely
       |
0000000|                if(s.length && s[0] == '#')
0000000|                        s = s[1 .. $];
       |
       |                // not a built in... do it as a hex string
0000000|                if(s.length >= 2) {
0000000|                        c.r = fromHexInternal(s[0 .. 2]);
0000000|                        s = s[2 .. $];
       |                }
0000000|                if(s.length >= 2) {
0000000|                        c.g = fromHexInternal(s[0 .. 2]);
0000000|                        s = s[2 .. $];
       |                }
0000000|                if(s.length >= 2) {
0000000|                        c.b = fromHexInternal(s[0 .. 2]);
0000000|                        s = s[2 .. $];
       |                }
0000000|                if(s.length >= 2) {
0000000|                        c.a = fromHexInternal(s[0 .. 2]);
0000000|                        s = s[2 .. $];
       |                }
       |
0000000|                return c;
       |        }
       |
       |        /// from hsl
       |        static Color fromHsl(real h, real s, real l) {
0000000|                return .fromHsl(h, s, l);
       |        }
       |}
       |
       |private string toHexInternal(ubyte b) {
0000000|        string s;
0000000|        if(b < 16)
0000000|                s ~= '0';
       |        else {
0000000|                ubyte t = (b & 0xf0) >> 4;
0000000|                if(t >= 10)
0000000|                        s ~= 'A' + t - 10;
       |                else
0000000|                        s ~= '0' + t;
0000000|                b &= 0x0f;
       |        }
0000000|        if(b >= 10)
0000000|                s ~= 'A' + b - 10;
       |        else
0000000|                s ~= '0' + b;
       |
0000000|        return s;
       |}
       |
       |private ubyte fromHexInternal(string s) {
0000000|        int result = 0;
       |
0000000|        int exp = 1;
       |        //foreach(c; retro(s)) { // FIXME: retro doesn't work right in dtojs
0000000|        foreach_reverse(c; s) {
0000000|                if(c >= 'A' && c <= 'F')
0000000|                        result += exp * (c - 'A' + 10);
0000000|                else if(c >= 'a' && c <= 'f')
0000000|                        result += exp * (c - 'a' + 10);
0000000|                else if(c >= '0' && c <= '9')
0000000|                        result += exp * (c - '0');
       |                else
       |                        // throw new Exception("invalid hex character: " ~ cast(char) c);
0000000|                        return 0;
       |
0000000|                exp *= 16;
       |        }
       |
0000000|        return cast(ubyte) result;
       |}
       |
       |/// Converts hsl to rgb
       |Color fromHsl(real[3] hsl) {
0000000|        return fromHsl(hsl[0], hsl[1], hsl[2]);
       |}
       |
       |/// Converts hsl to rgb
       |Color fromHsl(real h, real s, real l, real a = 255) {
0000000|        h = h % 360;
       |
0000000|        real C = (1 - absInternal(2 * l - 1)) * s;
       |
0000000|        real hPrime = h / 60;
       |
0000000|        real X = C * (1 - absInternal(hPrime % 2 - 1));
       |
0000000|        real r, g, b;
       |
0000000|        if(h is real.nan)
0000000|                r = g = b = 0;
0000000|        else if (hPrime >= 0 && hPrime < 1) {
0000000|                r = C;
0000000|                g = X;
0000000|                b = 0;
0000000|        } else if (hPrime >= 1 && hPrime < 2) {
0000000|                r = X;
0000000|                g = C;
0000000|                b = 0;
0000000|        } else if (hPrime >= 2 && hPrime < 3) {
0000000|                r = 0;
0000000|                g = C;
0000000|                b = X;
0000000|        } else if (hPrime >= 3 && hPrime < 4) {
0000000|                r = 0;
0000000|                g = X;
0000000|                b = C;
0000000|        } else if (hPrime >= 4 && hPrime < 5) {
0000000|                r = X;
0000000|                g = 0;
0000000|                b = C;
0000000|        } else if (hPrime >= 5 && hPrime < 6) {
0000000|                r = C;
0000000|                g = 0;
0000000|                b = X;
       |        }
       |
0000000|        real m = l - C / 2;
       |
0000000|        r += m;
0000000|        g += m;
0000000|        b += m;
       |
0000000|        return Color(
       |                cast(ubyte)(r * 255),
       |                cast(ubyte)(g * 255),
       |                cast(ubyte)(b * 255),
       |                cast(ubyte)(a));
       |}
       |
       |/// Converts an RGB color into an HSL triplet. useWeightedLightness will try to get a better value for luminosity for the human eye, which is more sensitive to green than red and more to red than blue. If it is false, it just does average of the rgb.
       |real[3] toHsl(Color c, bool useWeightedLightness = false) {
0000000|        real r1 = cast(real) c.r / 255;
0000000|        real g1 = cast(real) c.g / 255;
0000000|        real b1 = cast(real) c.b / 255;
       |
0000000|        real maxColor = maxInternal(r1, g1, b1);
0000000|        real minColor = minInternal(r1, g1, b1);
       |
0000000|        real L = (maxColor + minColor) / 2 ;
0000000|        if(useWeightedLightness) {
       |                // the colors don't affect the eye equally
       |                // this is a little more accurate than plain HSL numbers
0000000|                L = 0.2126*r1 + 0.7152*g1 + 0.0722*b1;
       |        }
0000000|        real S = 0;
0000000|        real H = 0;
0000000|        if(maxColor != minColor) {
0000000|                if(L < 0.5) {
0000000|                        S = (maxColor - minColor) / (maxColor + minColor);
       |                } else {
0000000|                        S = (maxColor - minColor) / (2.0 - maxColor - minColor);
       |                }
0000000|                if(r1 == maxColor) {
0000000|                        H = (g1-b1) / (maxColor - minColor);
0000000|                } else if(g1 == maxColor) {
0000000|                        H = 2.0 + (b1 - r1) / (maxColor - minColor);
       |                } else {
0000000|                        H = 4.0 + (r1 - g1) / (maxColor - minColor);
       |                }
       |        }
       |
0000000|        H = H * 60;
0000000|        if(H < 0){
0000000|                H += 360;
       |        }
       |
0000000|        return [H, S, L]; 
       |}
       |
       |/// .
       |Color lighten(Color c, real percentage) {
0000000|        auto hsl = toHsl(c);
0000000|        hsl[2] *= (1 + percentage);
0000000|        if(hsl[2] > 1)
0000000|                hsl[2] = 1;
0000000|        return fromHsl(hsl);
       |}
       |
       |/// .
       |Color darken(Color c, real percentage) {
0000000|        auto hsl = toHsl(c);
0000000|        hsl[2] *= (1 - percentage);
0000000|        return fromHsl(hsl);
       |}
       |
       |/// for light colors, call darken. for dark colors, call lighten.
       |/// The goal: get toward center grey.
       |Color moderate(Color c, real percentage) {
0000000|        auto hsl = toHsl(c);
0000000|        if(hsl[2] > 0.5)
0000000|                hsl[2] *= (1 - percentage);
       |        else {
0000000|                if(hsl[2] <= 0.01) // if we are given black, moderating it means getting *something* out
0000000|                        hsl[2] = percentage;
       |                else
0000000|                        hsl[2] *= (1 + percentage);
       |        }
0000000|        if(hsl[2] > 1)
0000000|                hsl[2] = 1;
0000000|        return fromHsl(hsl);
       |}
       |
       |/// the opposite of moderate. Make darks darker and lights lighter
       |Color extremify(Color c, real percentage) {
0000000|        auto hsl = toHsl(c, true);
0000000|        if(hsl[2] < 0.5)
0000000|                hsl[2] *= (1 - percentage);
       |        else
0000000|                hsl[2] *= (1 + percentage);
0000000|        if(hsl[2] > 1)
0000000|                hsl[2] = 1;
0000000|        return fromHsl(hsl);
       |}
       |
       |/// Move around the lightness wheel, trying not to break on moderate things
       |Color oppositeLightness(Color c) {
0000000|        auto hsl = toHsl(c);
       |
0000000|        auto original = hsl[2];
       |
0000000|        if(original > 0.4 && original < 0.6)
0000000|                hsl[2] = 0.8 - original; // so it isn't quite the same
       |        else
0000000|                hsl[2] = 1 - original;
       |
0000000|        return fromHsl(hsl);
       |}
       |
       |/// Try to determine a text color - either white or black - based on the input
       |Color makeTextColor(Color c) {
0000000|        auto hsl = toHsl(c, true); // give green a bonus for contrast
0000000|        if(hsl[2] > 0.71)
0000000|                return Color(0, 0, 0);
       |        else
0000000|                return Color(255, 255, 255);
       |}
       |
       |// These provide functional access to hsl manipulation; useful if you need a delegate
       |
       |Color setLightness(Color c, real lightness) {
0000000|        auto hsl = toHsl(c);
0000000|        hsl[2] = lightness;
0000000|        return fromHsl(hsl);
       |}
       |
       |
       |
       |Color rotateHue(Color c, real degrees) {
0000000|        auto hsl = toHsl(c);
0000000|        hsl[0] += degrees;
0000000|        return fromHsl(hsl);
       |}
       |
       |Color setHue(Color c, real hue) {
0000000|        auto hsl = toHsl(c);
0000000|        hsl[0] = hue;
0000000|        return fromHsl(hsl);
       |}
       |
       |Color desaturate(Color c, real percentage) {
0000000|        auto hsl = toHsl(c);
0000000|        hsl[1] *= (1 - percentage);
0000000|        return fromHsl(hsl);
       |}
       |
       |Color saturate(Color c, real percentage) {
0000000|        auto hsl = toHsl(c);
0000000|        hsl[1] *= (1 + percentage);
0000000|        if(hsl[1] > 1)
0000000|                hsl[1] = 1;
0000000|        return fromHsl(hsl);
       |}
       |
       |Color setSaturation(Color c, real saturation) {
0000000|        auto hsl = toHsl(c);
0000000|        hsl[1] = saturation;
0000000|        return fromHsl(hsl);
       |}
       |
       |
       |/*
       |void main(string[] args) {
       |        auto color1 = toHsl(Color(255, 0, 0));
       |        auto color = fromHsl(color1[0] + 60, color1[1], color1[2]);
       |
       |        writefln("#%02x%02x%02x", color.r, color.g, color.b);
       |}
       |*/
       |
       |/* Color algebra functions */
       |
       |/* Alpha putpixel looks like this:
       |
       |void putPixel(Image i, Color c) {
       |        Color b;
       |        b.r = i.data[(y * i.width + x) * bpp + 0];
       |        b.g = i.data[(y * i.width + x) * bpp + 1];
       |        b.b = i.data[(y * i.width + x) * bpp + 2];
       |        b.a = i.data[(y * i.width + x) * bpp + 3];
       |
       |        float ca = cast(float) c.a / 255;
       |
       |        i.data[(y * i.width + x) * bpp + 0] = alpha(c.r, ca, b.r);
       |        i.data[(y * i.width + x) * bpp + 1] = alpha(c.g, ca, b.g);
       |        i.data[(y * i.width + x) * bpp + 2] = alpha(c.b, ca, b.b);
       |        i.data[(y * i.width + x) * bpp + 3] = alpha(c.a, ca, b.a);
       |}
       |
       |ubyte alpha(ubyte c1, float alpha, ubyte onto) {
       |        auto got = (1 - alpha) * onto + alpha * c1;
       |
       |        if(got > 255)
       |                return 255;
       |        return cast(ubyte) got;
       |}
       |
       |So, given the background color and the resultant color, what was
       |composited on to it?
       |*/
       |
       |ubyte unalpha(ubyte colorYouHave, float alpha, ubyte backgroundColor) {
       |        // resultingColor = (1-alpha) * backgroundColor + alpha * answer
0000000|        auto resultingColorf = cast(float) colorYouHave;
0000000|        auto backgroundColorf = cast(float) backgroundColor;
       |
0000000|        auto answer = (resultingColorf - backgroundColorf + alpha * backgroundColorf) / alpha;
0000000|        if(answer > 255)
0000000|                return 255;
0000000|        if(answer < 0)
0000000|                return 0;
0000000|        return cast(ubyte) answer;
       |}
       |
       |ubyte makeAlpha(ubyte colorYouHave, ubyte backgroundColor/*, ubyte foreground = 0x00*/) {
       |        //auto foregroundf = cast(float) foreground;
0000000|        auto foregroundf = 0.00f;
0000000|        auto colorYouHavef = cast(float) colorYouHave;
0000000|        auto backgroundColorf = cast(float) backgroundColor;
       |
       |        // colorYouHave = backgroundColorf - alpha * backgroundColorf + alpha * foregroundf
0000000|        auto alphaf = 1 - colorYouHave / backgroundColorf;
0000000|        alphaf *= 255;
       |
0000000|        if(alphaf < 0)
0000000|                return 0;
0000000|        if(alphaf > 255)
0000000|                return 255;
0000000|        return cast(ubyte) alphaf;
       |}
       |
       |
       |int fromHex(string s) {
0000000|        int result = 0;
       |
0000000|        int exp = 1;
       |        // foreach(c; retro(s)) {
0000000|        foreach_reverse(c; s) {
0000000|                if(c >= 'A' && c <= 'F')
0000000|                        result += exp * (c - 'A' + 10);
0000000|                else if(c >= 'a' && c <= 'f')
0000000|                        result += exp * (c - 'a' + 10);
0000000|                else if(c >= '0' && c <= '9')
0000000|                        result += exp * (c - '0');
       |                else
0000000|                        throw new Exception("invalid hex character: " ~ cast(char) c);
       |
0000000|                exp *= 16;
       |        }
       |
0000000|        return result;
       |}
       |
       |Color colorFromString(string s) {
0000000|        if(s.length == 0)
0000000|                return Color(0,0,0,255);
0000000|        if(s[0] == '#')
0000000|                s = s[1..$];
0000000|        assert(s.length == 6 || s.length == 8);
       |
0000000|        Color c;
       |
0000000|        c.r = cast(ubyte) fromHex(s[0..2]);
0000000|        c.g = cast(ubyte) fromHex(s[2..4]);
0000000|        c.b = cast(ubyte) fromHex(s[4..6]);
0000000|        if(s.length == 8)
0000000|                c.a = cast(ubyte) fromHex(s[6..8]);
       |        else
0000000|                c.a = 255;
       |
0000000|        return c;
       |}
       |
       |/*
       |import browser.window;
       |import std.conv;
       |void main() {
       |        import browser.document;
       |        foreach(ele; document.querySelectorAll("input")) {
       |                ele.addEventListener("change", {
       |                        auto h = toInternal!real(document.querySelector("input[name=h]").value);
       |                        auto s = toInternal!real(document.querySelector("input[name=s]").value);
       |                        auto l = toInternal!real(document.querySelector("input[name=l]").value);
       |
       |                        Color c = Color.fromHsl(h, s, l);
       |
       |                        auto e = document.getElementById("example");
       |                        e.style.backgroundColor = c.toCssString();
       |
       |                        // JSElement __js_this;
       |                        // __js_this.style.backgroundColor = c.toCssString();
       |                }, false);
       |        }
       |}
       |*/
       |
       |
       |
       |/**
       |        This provides two image classes and a bunch of functions that work on them.
       |
       |        Why are they separate classes? I think the operations on the two of them
       |        are necessarily different. There's a whole bunch of operations that only
       |        really work on truecolor (blurs, gradients), and a few that only work
       |        on indexed images (palette swaps).
       |
       |        Even putpixel is pretty different. On indexed, it is a palette entry's
       |        index number. On truecolor, it is the actual color.
       |
       |        A greyscale image is the weird thing in the middle. It is truecolor, but
       |        fits in the same size as indexed. Still, I'd say it is a specialization
       |        of truecolor.
       |
       |        There is a subset that works on both
       |
       |*/
       |
       |/// An image in memory
       |interface MemoryImage {
       |        //IndexedImage convertToIndexedImage() const;
       |        //TrueColorImage convertToTrueColor() const;
       |
       |        /// gets it as a TrueColorImage. May return this or may do a conversion and return a new image
       |        TrueColorImage getAsTrueColorImage();
       |
       |        /// Image width, in pixels
       |        int width() const;
       |
       |        /// Image height, in pixels
       |        int height() const;
       |}
       |
       |/// An image that consists of indexes into a color palette. Use getAsTrueColorImage() if you don't care about palettes
       |class IndexedImage : MemoryImage {
       |        bool hasAlpha;
       |
       |        /// .
       |        Color[] palette;
       |        /// the data as indexes into the palette. Stored left to right, top to bottom, no padding.
       |        ubyte[] data;
       |
       |        /// .
       |        override int width() const {
0000000|                return _width;
       |        }
       |
       |        /// .
       |        override int height() const {
0000000|                return _height;
       |        }
       |
       |        private int _width;
       |        private int _height;
       |
       |        /// .
0000000|        this(int w, int h) {
0000000|                _width = w;
0000000|                _height = h;
0000000|                data = new ubyte[w*h];
       |        }
       |
       |        /*
       |        void resize(int w, int h, bool scale) {
       |
       |        }
       |        */
       |
       |        /// returns a new image
       |        override TrueColorImage getAsTrueColorImage() {
0000000|                return convertToTrueColor();
       |        }
       |
       |        /// Creates a new TrueColorImage based on this data
       |        TrueColorImage convertToTrueColor() const {
0000000|                auto tci = new TrueColorImage(width, height);
0000000|                foreach(i, b; data) {
       |                        /*
       |                        if(b >= palette.length) {
       |                                string fuckyou;
       |                                fuckyou ~= b + '0';
       |                                fuckyou ~= " ";
       |                                fuckyou ~= palette.length + '0';
       |                                assert(0, fuckyou);
       |                        }
       |                        */
0000000|                        tci.imageData.colors[i] = palette[b];
       |                }
0000000|                return tci;
       |        }
       |
       |        /// Gets an exact match, if possible, adds if not. See also: the findNearestColor free function.
       |        ubyte getOrAddColor(Color c) {
0000000|                foreach(i, co; palette) {
0000000|                        if(c == co)
0000000|                                return cast(ubyte) i;
       |                }
       |
0000000|                return addColor(c);
       |        }
       |
       |        /// Number of colors currently in the palette (note: palette entries are not necessarily used in the image data)
       |        int numColors() const {
0000000|                return cast(int) palette.length;
       |        }
       |
       |        /// Adds an entry to the palette, returning its inded
       |        ubyte addColor(Color c) {
0000000|                assert(palette.length < 256);
0000000|                if(c.a != 255)
0000000|                        hasAlpha = true;
0000000|                palette ~= c;
       |
0000000|                return cast(ubyte) (palette.length - 1);
       |        }
       |}
       |
       |/// An RGBA array of image data. Use the free function quantize() to convert to an IndexedImage
       |class TrueColorImage : MemoryImage {
       |//      bool hasAlpha;
       |//      bool isGreyscale;
       |
       |        //ubyte[] data; // stored as rgba quads, upper left to right to bottom
       |        /// .
       |        struct Data {
       |                ubyte[] bytes; /// the data as rgba bytes. Stored left to right, top to bottom, no padding.
       |                // the union is no good because the length of the struct is wrong!
       |
       |                /// the same data as Color structs
       |                @trusted // the cast here is typically unsafe, but it is ok
       |                // here because I guarantee the layout, note the static assert below
       |                @property inout(Color)[] colors() inout {
0000000|                        return cast(inout(Color)[]) bytes;
       |                }
       |
       |                static assert(Color.sizeof == 4);
       |        }
       |
       |        /// .
       |        Data imageData;
       |        alias imageData.bytes data;
       |
       |        int _width;
       |        int _height;
       |
       |        /// .
0000000|        override int width() const { return _width; }
       |        ///.
0000000|        override int height() const { return _height; }
       |
       |        /// .
0000000|        this(int w, int h) {
0000000|                _width = w;
0000000|                _height = h;
0000000|                imageData.bytes = new ubyte[w*h*4];
       |        }
       |
       |        /// Creates with existing data. The data pointer is stored here.
0000000|        this(int w, int h, ubyte[] data) {
0000000|                _width = w;
0000000|                _height = h;
0000000|                assert(data.length == w * h * 4);
0000000|                imageData.bytes = data;
       |        }
       |
       |        /// Returns this
       |        override TrueColorImage getAsTrueColorImage() {
0000000|                return this;
       |        }
       |}
       |
       |/// Converts true color to an indexed image. It uses palette as the starting point, adding entries
       |/// until maxColors as needed. If palette is null, it creates a whole new palette.
       |///
       |/// After quantizing the image, it applies a dithering algorithm.
       |///
       |/// This is not written for speed.
       |IndexedImage quantize(in TrueColorImage img, Color[] palette = null, in int maxColors = 256)
       |        // this is just because IndexedImage assumes ubyte palette values
0000000|        in { assert(maxColors <= 256); }
       |body {
0000000|        int[Color] uses;
0000000|        foreach(pixel; img.imageData.colors) {
0000000|                if(auto i = pixel in uses) {
0000000|                        (*i)++;
       |                } else {
0000000|                        uses[pixel] = 1;
       |                }
       |        }
       |
0000000|        struct ColorUse {
       |                Color c;
       |                int uses;
       |                //string toString() { import std.conv; return c.toCssString() ~ " x " ~ to!string(uses); }
       |                int opCmp(ref const ColorUse co) const {
0000000|                        return co.uses - uses;
       |                }
       |        }
       |
0000000|        ColorUse[] sorted;
       |
0000000|        foreach(color, count; uses)
0000000|                sorted ~= ColorUse(color, count);
       |
0000000|        uses = null;
       |        version(no_phobos)
       |                sorted = sorted.sort;
       |        else {
       |                import std.algorithm : sort;
0000000|                sort(sorted);
       |        }
       |
0000000|        ubyte[Color] paletteAssignments;
0000000|        foreach(idx, entry; palette)
0000000|                paletteAssignments[entry] = cast(ubyte) idx;
       |
       |        // For the color assignments from the image, I do multiple passes, decreasing the acceptable
       |        // distance each time until we're full.
       |
       |        // This is probably really slow.... but meh it gives pretty good results.
       |
0000000|        auto ddiff = 32;
0000000|        outer: for(int d1 = 128; d1 >= 0; d1 -= ddiff) {
0000000|        auto minDist = d1*d1;
0000000|        if(d1 <= 64)
0000000|                ddiff = 16;
0000000|        if(d1 <= 32)
0000000|                ddiff = 8;
0000000|        foreach(possibility; sorted) {
0000000|                if(palette.length == maxColors)
0000000|                        break;
0000000|                if(palette.length) {
0000000|                        auto co = palette[findNearestColor(palette, possibility.c)];
0000000|                        auto pixel = possibility.c;
       |
0000000|                        auto dr = cast(int) co.r - pixel.r;
0000000|                        auto dg = cast(int) co.g - pixel.g;
0000000|                        auto db = cast(int) co.b - pixel.b;
       |
0000000|                        auto dist = dr*dr + dg*dg + db*db;
       |                        // not good enough variety to justify an allocation yet
0000000|                        if(dist < minDist)
0000000|                                continue;
       |                }
0000000|                paletteAssignments[possibility.c] = cast(ubyte) palette.length;
0000000|                palette ~= possibility.c;
       |        }
       |        }
       |
       |        // Final pass: just fill in any remaining space with the leftover common colors
0000000|        while(palette.length < maxColors && sorted.length) {
0000000|                if(sorted[0].c !in paletteAssignments) {
0000000|                        paletteAssignments[sorted[0].c] = cast(ubyte) palette.length;
0000000|                        palette ~= sorted[0].c;
       |                }
0000000|                sorted = sorted[1 .. $];
       |        }
       |
       |
0000000|        bool wasPerfect = true;
0000000|        auto newImage = new IndexedImage(img.width, img.height);
0000000|        newImage.palette = palette;
0000000|        foreach(idx, pixel; img.imageData.colors) {
0000000|                if(auto p = pixel in paletteAssignments)
0000000|                        newImage.data[idx] = *p;
       |                else {
       |                        // gotta find the closest one...
0000000|                        newImage.data[idx] = findNearestColor(palette, pixel);
0000000|                        wasPerfect = false;
       |                }
       |        }
       |
0000000|        if(!wasPerfect)
0000000|                floydSteinbergDither(newImage, img);
       |
0000000|        return newImage;
       |}
       |
       |/// Finds the best match for pixel in palette (currently by checking for minimum euclidean distance in rgb colorspace)
       |ubyte findNearestColor(in Color[] palette, in Color pixel) {
0000000|        int best = 0;
0000000|        int bestDistance = int.max;
0000000|        foreach(pe, co; palette) {
0000000|                auto dr = cast(int) co.r - pixel.r;
0000000|                auto dg = cast(int) co.g - pixel.g;
0000000|                auto db = cast(int) co.b - pixel.b;
0000000|                int dist = dr*dr + dg*dg + db*db;
       |
0000000|                if(dist < bestDistance) {
0000000|                        best = cast(int) pe;
0000000|                        bestDistance = dist;
       |                }
       |        }
       |
0000000|        return cast(ubyte) best;
       |}
       |
       |/+
       |
       |// Quantizing and dithering test program
       |
       |void main( ){
       |/*
       |        auto img = new TrueColorImage(256, 32);
       |        foreach(y; 0 .. img.height) {
       |                foreach(x; 0 .. img.width) {
       |                        img.imageData.colors[x + y * img.width] = Color(x, y * (255 / img.height), 0);
       |                }
       |        }
       |*/
       |
       |TrueColorImage img;
       |
       |{
       |
       |import arsd.png;
       |
       |struct P {
       |        ubyte[] range;
       |        void put(ubyte[] a) { range ~= a; }
       |}
       |
       |P range;
       |import std.algorithm;
       |
       |import std.stdio;
       |writePngLazy(range, pngFromBytes(File("/home/me/nyesha.png").byChunk(4096)).byRgbaScanline.map!((line) {
       |        foreach(ref pixel; line.pixels) {
       |        continue;
       |                auto sum = cast(int) pixel.r + pixel.g + pixel.b;
       |                ubyte a = cast(ubyte)(sum / 3);
       |                pixel.r = a;
       |                pixel.g = a;
       |                pixel.b = a;
       |        }
       |        return line;
       |}));
       |
       |img = imageFromPng(readPng(range.range)).getAsTrueColorImage;
       |
       |
       |}
       |
       |
       |
       |        auto qimg = quantize(img, null, 2);
       |
       |        import simpledisplay;
       |        auto win = new SimpleWindow(img.width, img.height * 3);
       |        auto painter = win.draw();
       |        painter.drawImage(Point(0, 0), Image.fromMemoryImage(img));
       |        painter.drawImage(Point(0, img.height), Image.fromMemoryImage(qimg));
       |        floydSteinbergDither(qimg, img);
       |        painter.drawImage(Point(0, img.height * 2), Image.fromMemoryImage(qimg));
       |        win.eventLoop(0);
       |}
       |+/
       |
       |/+
       |/// If the background is transparent, it simply erases the alpha channel.
       |void removeTransparency(IndexedImage img, Color background)
       |+/
       |
       |Color alphaBlend(Color foreground, Color background) {
0000000|        if(foreground.a != 255)
0000000|        foreach(idx, ref part; foreground.components) {
0000000|                part = cast(ubyte) (part * foreground.a / 255 +
       |                        background.components[idx] * (255 - foreground.a) / 255);
       |        }
       |
0000000|        return foreground;
       |}
       |
       |/*
       |/// Reduces the number of colors in a palette.
       |void reducePaletteSize(IndexedImage img, int maxColors = 16) {
       |
       |}
       |*/
       |
       |// I think I did this wrong... but the results aren't too bad so the bug can't be awful.
       |/// Dithers img in place to look more like original.
       |void floydSteinbergDither(IndexedImage img, in TrueColorImage original) {
0000000|        assert(img.width == original.width);
0000000|        assert(img.height == original.height);
       |
0000000|        auto buffer = new Color[](original.imageData.colors.length);
       |
0000000|        int x, y;
       |
0000000|        foreach(idx, c; original.imageData.colors) {
0000000|                auto n = img.palette[img.data[idx]];
0000000|                int errorR = cast(int) c.r - n.r;
0000000|                int errorG = cast(int) c.g - n.g;
0000000|                int errorB = cast(int) c.b - n.b;
       |
0000000|                void doit(int idxOffset, int multiplier) {
       |                //      if(idx + idxOffset < buffer.length)
0000000|                                buffer[idx + idxOffset] = Color.fromIntegers(
       |                                        c.r + multiplier * errorR / 16,
       |                                        c.g + multiplier * errorG / 16,
       |                                        c.b + multiplier * errorB / 16,
       |                                        c.a
       |                                );
       |                }
       |
0000000|                if((x+1) != original.width)
0000000|                        doit(1, 7);
0000000|                if((y+1) != original.height) {
0000000|                        if(x != 0)
0000000|                                doit(-1 + img.width, 3);
0000000|                        doit(img.width, 5);
0000000|                        if(x+1 != original.width)
0000000|                                doit(1 + img.width, 1);
       |                }
       |
0000000|                img.data[idx] = findNearestColor(img.palette, buffer[idx]);
       |
0000000|                x++;
0000000|                if(x == original.width) {
0000000|                        x = 0;
0000000|                        y++;
       |                }
       |        }
       |}
       |
       |// these are just really useful in a lot of places where the color/image functions are used,
       |// so I want them available with Color
       |struct Point {
       |        int x;
       |        int y;
       |}
       |
       |struct Size {
       |        int width;
       |        int height;
       |}
       |
       |struct Rectangle {
       |        int left;
       |        int top;
       |        int right;
       |        int bottom;
       |}
source\color.d is 1% covered
