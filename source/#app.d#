import std.random, std.math, std.range, std.algorithm, std.array,
	std.stdio, std.process, std.conv, std.typecons, std.container,
	std.variant, std.traits;
import bird, gameObject;
import core.runtime;
import dlib.math.vector : vec3;
static import simpledisplay;
alias sd = simpledisplay;
static import dlib;

alias InputEvent = Algebraic!(sd.KeyEvent, sd.MouseEvent);

enum collectLength = 500;
enum delta = .04f;


struct Functor(alias f){
	Parameters!f[0] state;
	auto opCall(Parameters!f[1 .. $] par){
		return f(state, par);
	}
	this (Parameters!f[0] a){
		state = a;
	}
}

auto cumulative(Range)(Range base)
	if (isInputRange!Range)
{	return Cumulative!(Range, ReturnType!(Range.front))(base);
}
struct Cumulative(Range, Elem)
	if (isInputRange!Range)
{  Range base;
	Elem soFar;
	bool frontCalculated = false;
	static if (isForwardRange!Range)
	{	this(this)
	{	base = base.save;
	}}
	ref front()
	{	if (!frontCalculated)
		{	soFar += base.front;
			frontCalculated = true;
		}
		return soFar;
	}
	void popFront()
	{	front;
		base.popFront;
		frontCalculated = false;
	}
	bool empty()
	{	return base.empty;
	}
	static if (isForwardRange!Range)
	{	auto save() inout
	{	return this;
	}}
}

void generate(C)(C mission, int times){
	static if (is(void == ReturnType!mission)){
		mission
			.repeat(times)
			.each!(a => a());
	} else {
		mission
			.generate
			.take(times);
	}
	return;
}

class GameBoard{
	auto size = sd.Point(640, 480);
	int drops = 0;
	float time = 0;
	GameObject[] content;
	
	this()
	{	foreach(i; 0 .. 5){content ~= new Bird;}
	}
	private class Bird : bird.Bird
	{  int _hitPoints = 2;
	  ref int hitPoints() @property {return _hitPoints;}
		this()
		{	position = vec3(-20, 0.uniform(GameBoard.size.y / 2), normalZ);
			velocity = vec3(uniform(150, 250), 0, normalZ);
			if (dice(50, 50)){
				position.x = GameBoard.size.x + 20;
				velocity.x *= -1;
			}
		}
		override bool outOfArea()
		{	if (-Bird.size.x <= position.x && position.x <= GameBoard.size.x + Bird.size.x)
				return true;
			return position.x.sgn != velocity.x.sgn;
		}
		override void retire(){}
        }
}



void main() {
	auto board = new GameBoard;
	auto window = new sd.SimpleWindow(640, 480, "Kaksipiippuinen");

	/+(() => board.serve)
		.generate(5);+/

	window.eventLoop((delta*1000).to!int,
		delegate () {
			try{
				board.step; draw(window, board);
			} catch(Throwable e){
				e.toString((a){a.writeln;});
				stdout.flush;
				Runtime.terminate;
			}
		},
		delegate (sd.KeyEvent event) {},
		delegate (sd.MouseEvent event) {}
	);
}

/+struct Shot{
	dlib.Sphere shape;
	alias shape this;
	ref position() @property inout {return shape.center;}
	enum velocity = vec3(0, 0, 200);
}+/

/+auto step(ref Bird obj){
	obj.position += obj.velocity * delta;
	return obj;
}

auto effective(Bird a, in GameBoard where){
	if (-Bird.size.x <= a.position.x && a.position.x <= where.size.x + Bird.size.x)
		return true;
	return a.position.x.sgn != a.velocity.x.sgn;
}+/

auto alive(Bird what){return what.hitPoints > 0;}
unittest{
	auto rabbit = Bird.init;
	assert(rabbit.alive);
	rabbit.hitPoints = 0;
	assert(!rabbit.alive);
	rabbit.hitpoints -= 10;
	assert(!rabbit.alive);
}

/+auto step(ref Shot obj){
	obj.position += obj.velocity * delta;
	return obj;
}

auto effective(in Shot obj, in GameBoard where){
	return obj.position.z < 50;
}+/

void step(ref GameBoard board){
	with(board)
{
	if (dice(97, 3)) board.content ~= board.new Bird;
	content =
		content
		.filter!(a => a.step(delta))
		.array;
	/+shots =
		shots
		.filter!(a => a.effective(board))
		.array;
	shots.each!((ref Shot a){
		a.step;
	});
	board.time += delta;
	schelude[ ]
		.until!(a => a.state.time < board.time)
		.each!"a( )";+/
}}

void draw(sd.SimpleWindow window, GameBoard board){
	auto painter = window.draw();
	painter.clear;
	painter.outlineColor = sd.Color.black;
	painter.fillColor = sd.Color.black;

	board.content.each!( (GameObject na){
		if(auto a = cast(Bird)na)
	{
        auto paintPos = sd.Point(a.position.x.to!int, a.position.y.to!int);
        paintPos.x -= Bird.size.x / 2;
        paintPos.y -= Bird.size.y / 2;
		painter.drawRectangle(paintPos, Bird.size.x, Bird.size.y);
	}});
}

/+void serve(ref GameBoard where) {
	where.content ~= where.new Bird;
} +/
